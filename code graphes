#include <stdio.h>
#include <stdlib.h> // Pour malloc, free, exit
#include <string.h> // Pour memset
#include <limits.h> // Pour INT_MAX

// Valeur pour représenter l'infini
// On prend INT_MAX / 2 pour éviter les dépassements (overflow) lors d'additions
#define INF (INT_MAX / 2)

// --- Prototypes des fonctions ---
int** allouer_matrice(int n);
void liberer_matrice(int** matrice, int n);
void afficher_matrice(int** matrice, int n, char* nom);
void afficher_matrice_pred(int** matrice, int n, char* nom);
int** charger_graphe(char* nom_fichier, int* n_sommets_ret);
void floyd_warshall(int** graphe, int n);
void interface_chemins(int** dist, int** pred, int n);
void reconstruire_chemin(int** pred, int i, int j);

/**
 * Fonction principale : boucle de traitement des graphes
 */
int main() {
    char nom_fichier[100];
    int n_sommets = 0;
    int** graphe = NULL;

    while (1) {
        printf("\n-----------------------------------------------------\n");
        printf("Entrez le nom du fichier graphe (ex: graphe1.txt) ou 'q' pour quitter : ");
        scanf("%s", nom_fichier);

        if (strcmp(nom_fichier, "q") == 0) {
            break; // Quitter la boucle principale
        }

        // 1. Chargement du graphe
        graphe = charger_graphe(nom_fichier, &n_sommets);
        if (graphe == NULL) {
            printf("Erreur: Impossible de charger le fichier %s\n", nom_fichier);
            continue; // Revenir au début de la boucle
        }

        // 2. Affichage du graphe initial (matrice d'adjacence)
        printf("\n(3) Graphe initial lu depuis le fichier :\n");
        afficher_matrice(graphe, n_sommets, "Graphe (L-1)");

        // 3. Exécution de l'algorithme
        printf("\n(5) Execution de Floyd-Warshall...\n");
        floyd_warshall(graphe, n_sommets);

        // 4. Libération de la mémoire pour ce graphe
        liberer_matrice(graphe, n_sommets);
        graphe = NULL;
    }

    printf("Fin du programme.\n");
    return 0;
}

/**
 * Alloue dynamiquement une matrice n x n
 */
int** allouer_matrice(int n) {
    int** matrice = (int**)malloc(n * sizeof(int*));
    if (matrice == NULL) {
        perror("Erreur d'allocation memoire");
        exit(EXIT_FAILURE);
    }
    for (int i = 0; i < n; i++) {
        matrice[i] = (int*)malloc(n * sizeof(int));
        if (matrice[i] == NULL) {
            perror("Erreur d'allocation memoire");
            exit(EXIT_FAILURE);
        }
    }
    return matrice;
}

/**
 * Libère la mémoire d'une matrice n x n
 */
void liberer_matrice(int** matrice, int n) {
    if (matrice == NULL) return;
    for (int i = 0; i < n; i++) {
        free(matrice[i]);
    }
    free(matrice);
}

/**
 * Affiche une matrice de poids de manière lisible
 */
void afficher_matrice(int** matrice, int n, char* nom) {
    printf("\n--- Matrice %s ---\n", nom);
    // En-tête (colonnes)
    printf("     ");
    for (int j = 0; j < n; j++) {
        printf("%5d ", j);
    }
    printf("\n    ");
    for (int j = 0; j < n; j++) {
        printf("------");
    }
    printf("\n");

    // Lignes
    for (int i = 0; i < n; i++) {
        printf("%3d |", i);
        for (int j = 0; j < n; j++) {
            if (matrice[i][j] == INF) {
                printf("%5s ", "inf");
            } else {
                printf("%5d ", matrice[i][j]);
            }
        }
        printf("\n");
    }
}

/**
 * Affiche une matrice de prédécesseurs (P)
 */
void afficher_matrice_pred(int** matrice, int n, char* nom) {
    printf("\n--- Matrice %s ---\n", nom);
    // En-tête (colonnes)
    printf("     ");
    for (int j = 0; j < n; j++) {
        printf("%5d ", j);
    }
    printf("\n    ");
    for (int j = 0; j < n; j++) {
        printf("------");
    }
    printf("\n");

    // Lignes
    for (int i = 0; i < n; i++) {
        printf("%3d |", i);
        for (int j = 0; j < n; j++) {
            if (matrice[i][j] == -1) {
                printf("%5s ", "NIL");
            } else {
                printf("%5d ", matrice[i][j]);
            }
        }
        printf("\n");
    }
}


/**
 * Charge un graphe depuis un fichier
 * Format Annexe:
 * L1: Nb Sommets
 * L2: Nb Arcs
 * L3..: u v poids
 */
int** charger_graphe(char* nom_fichier, int* n_sommets_ret) {
    FILE* f = fopen(nom_fichier, "r");
    if (f == NULL) {
        return NULL;
    }

    int n, n_arcs;
    // Ligne 1: Nombre de sommets
    fscanf(f, "%d", &n);
    // Ligne 2: Nombre d'arcs
    fscanf(f, "%d", &n_arcs);

    if (n <= 0) {
        printf("Nombre de sommets invalide.\n");
        fclose(f);
        return NULL;
    }

    // Allocation de la matrice
    int** graphe = allouer_matrice(n);

    // Initialisation: infini partout, 0 sur la diagonale
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i == j) {
                graphe[i][j] = 0;
            } else {
                graphe[i][j] = INF;
            }
        }
    }

    // Lecture des arcs
    int u, v, poids;
    for (int k = 0; k < n_arcs; k++) {
        if (fscanf(f, "%d %d %d", &u, &v, &poids) != 3) {
            printf("Erreur de formatage à la ligne %d du fichier.\n", k + 3);
            liberer_matrice(graphe, n);
            fclose(f);
            return NULL;
        }
        if (u >= 0 && u < n && v >= 0 && v < n) {
            graphe[u][v] = poids;
        }
    }

    fclose(f);
    *n_sommets_ret = n;
    
    // Le graphe est chargé, le programme n'accède plus au fichier [cite: 22]
    return graphe;
}

/**
 * Coeur de l'algorithme de Floyd-Warshall
 */
void floyd_warshall(int** graphe, int n) {
    // Allocation des matrices L (dist) et P (pred)
    int** dist = allouer_matrice(n);
    int** pred = allouer_matrice(n);

    // --- Initialisation L0 et P0 ---
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            dist[i][j] = graphe[i][j]; // L0 est la matrice d'adjacence
            
            if (i != j && graphe[i][j] != INF) {
                pred[i][j] = i; // Prédécesseur de j est i
            } else {
                pred[i][j] = -1; // -1 pour "NIL"
            }
            if (i == j && graphe[i][j] == 0) {
                pred[i][j] = i; // Prédécesseur de soi-même est soi-même
            }
        }
    }

    printf("\n(5) Affichage des matrices initiales :\n");
    afficher_matrice(dist, n, "L(0)");
    afficher_matrice_pred(pred, n, "P(0)");

    // --- Boucle principale de l'algorithme ---
    for (int k = 0; k < n; k++) { // k = sommet intermédiaire
        for (int i = 0; i < n; i++) { // i = sommet de départ
            for (int j = 0; j < n; j++) { // j = sommet d'arrivée

                // Vérification pour éviter overflow avec INF
                if (dist[i][k] != INF && dist[k][j] != INF) {
                    
                    int nouveau_chemin = dist[i][k] + dist[k][j];

                    if (nouveau_chemin < dist[i][j]) {
                        dist[i][j] = nouveau_chemin;
                        pred[i][j] = pred[k][j]; // Le prédécesseur de j (venant de i) est le même que celui (venant de k)
                    }
                }
            }
        }
        
        // Affichage des matrices intermédiaires L(k) et P(k) 
        char nom_mat[10];
        sprintf(nom_mat, "L(%d)", k + 1);
        afficher_matrice(dist, n, nom_mat);
        sprintf(nom_mat, "P(%d)", k + 1);
        afficher_matrice_pred(pred, n, nom_mat);
    }

    // --- (6) Détection de circuit absorbant ---
    printf("\n(6) Verification des circuits absorbants...\n");
    int circuit_absorbant = 0;
    for (int i = 0; i < n; i++) {
        if (dist[i][i] < 0) {
            printf("   !! Circuit absorbant detecte au sommet %d (valeur: %d) !!\n", i, dist[i][i]);
            circuit_absorbant = 1;
        }
    }
    if (!circuit_absorbant) {
         printf("   Aucun circuit absorbant detecte.\n");
    }

    // --- (7) Affichage des chemins ---
    if (!circuit_absorbant) {
        printf("\n(7) Affichage des chemins de valeurs minimales.\n");
        interface_chemins(dist, pred, n);
    } else {
        printf("\n(7) Le graphe contient un circuit absorbant, l'affichage des chemins est ignore.\n");
    }

    // Libération de la mémoire
    liberer_matrice(dist, n);
    liberer_matrice(pred, n);
}

/**
 * Interface utilisateur pour demander des chemins
 */
void interface_chemins(int** dist, int** pred, int n) {
    char reponse[10];
    int depart, arrivee;

    while (1) {
        printf("\nAfficher un chemin ? (o/n) : ");
        scanf("%s", reponse);

        if (strcmp(reponse, "n") == 0) { // [cite: 35]
            break;
        }
        
        if (strcmp(reponse, "o") == 0) { // [cite: 31]
            printf("Sommet de depart ? ");
            scanf("%d", &depart);
            printf("Sommet d'arrivee ? "); // [cite: 32]
            scanf("%d", &arrivee);

            if (depart < 0 || depart >= n || arrivee < 0 || arrivee >= n) {
                printf("Sommets invalides. Doivent etre entre 0 et %d.\n", n - 1);
                continue;
            }

            // Affichage du résultat
            printf("   Resultat :\n");
            if (dist[depart][arrivee] == INF) {
                printf("   Aucun chemin de %d a %d.\n", depart, arrivee);
            } else {
                printf("   Chemin de %d a %d (Cout: %d) : ", depart, arrivee, dist[depart][arrivee]);
                if (depart == arrivee) {
                    printf("%d\n", depart);
                } else {
                    reconstruire_chemin(pred, depart, arrivee);
                    printf("%d\n", arrivee); // Afficher le dernier sommet
                }
            }
        }
    }
}

/**
 * Fonction récursive pour reconstruire le chemin
 */
void reconstruire_chemin(int** pred, int i, int j) {
    if (i == j) {
        printf("%d -> ", i);
    } else if (pred[i][j] == -1) {
        printf(" (pas de chemin) ");
    } else {
        reconstruire_chemin(pred, i, pred[i][j]);
        printf("%d -> ", pred[i][j]);
    }
}

