/**
 * PROJET GRAPHE - FLOYD-WARSHALL
 * Module : SM501 / Mathématiques
 * Langage : C (ANSI/ISO)
 *
 * Auteur : [Votre Nom / Votre Equipe]
 * Description : Implémentation robuste de l'algorithme de Floyd-Warshall
 * avec gestion dynamique de la mémoire et détection de circuits absorbants.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

// --- CONSTANTES ---
#define INF 1000000000  // Valeur "Infinie" (suffisamment petite pour éviter l'overflow int à l'addition)
#define MAX_FILENAME 256

// --- STRUCTURES DE DONNEES ---
// Encapsulation du graphe pour une gestion propre
typedef struct {
    int n_sommets;      // Nombre de sommets
    int** L;            // Matrice des Longueurs (Poids)
    int** P;            // Matrice des Prédécesseurs
    int est_charge;     // Indicateur d'état (1 si chargé, 0 sinon)
} Graphe;

// --- PROTOTYPES ---
void vider_buffer();
int lire_entier_securise();
int** allouer_matrice(int n);
void liberer_matrice(int** mat, int n);
void initialiser_graphe(Graphe* g);
void detruire_graphe(Graphe* g);
int charger_graphe_fichier(const char* nom_fichier, Graphe* g);
void afficher_matrices(Graphe* g, int k);
void floyd_warshall(Graphe* g);
int detecter_circuit_absorbant(Graphe* g);
void afficher_chemin_recursif(Graphe* g, int depart, int arrivee);

// --- OUTILS DE SAISIE SECURISEE ---

// Vide le buffer d'entrée pour éviter les boucles infinies de scanf
void vider_buffer() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF);
}

// Force l'utilisateur à entrer un entier valide
int lire_entier_securise() {
    int valeur;
    while (scanf("%d", &valeur) != 1) {
        printf("Erreur : Veuillez entrer un nombre entier valide : ");
        vider_buffer();
    }
    // On consomme le reste de la ligne (ex: entrée 12abc -> lit 12, ignore abc)
    // vider_buffer(); // Optionnel selon le comportement désiré
    return valeur;
}

// --- GESTION MEMOIRE ---

int** allouer_matrice(int n) {
    if (n <= 0) return NULL;

    int** mat = (int**)malloc(n * sizeof(int*));
    if (mat == NULL) {
        fprintf(stderr, "Erreur fatale : Echec d'allocation memoire (lignes).\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < n; i++) {
        mat[i] = (int*)malloc(n * sizeof(int));
        if (mat[i] == NULL) {
            fprintf(stderr, "Erreur fatale : Echec d'allocation memoire (colonnes).\n");
            // Libération de ce qui a déjà été alloué avant de quitter
            for (int j = 0; j < i; j++) free(mat[j]);
            free(mat);
            exit(EXIT_FAILURE);
        }
    }
    return mat;
}

void liberer_matrice(int** mat, int n) {
    if (mat == NULL) return;
    for (int i = 0; i < n; i++) {
        free(mat[i]);
    }
    free(mat);
}

void initialiser_graphe(Graphe* g) {
    g->n_sommets = 0;
    g->L = NULL;
    g->P = NULL;
    g->est_charge = 0;
}

void detruire_graphe(Graphe* g) {
    if (g->est_charge) {
        liberer_matrice(g->L, g->n_sommets);
        liberer_matrice(g->P, g->n_sommets);
        g->est_charge = 0;
        g->n_sommets = 0;
    }
}

// --- CHARGEMENT ET FICHIERS ---

int charger_graphe_fichier(const char* nom_fichier, Graphe* g) {
    // Nettoyage préventif si un graphe était déjà chargé
    detruire_graphe(g);

    FILE* f = fopen(nom_fichier, "r");
    if (f == NULL) {
        printf("Erreur : Impossible d'ouvrir le fichier '%s'. Verifiez le nom.\n", nom_fichier);
        return 0; // Echec
    }

    // Lecture sécurisée des dimensions
    if (fscanf(f, "%d", &g->n_sommets) != 1) {
        printf("Erreur : Format de fichier invalide (nombre de sommets manquant).\n");
        fclose(f); return 0;
    }

    // Protection contre les graphes vides ou négatifs
    if (g->n_sommets <= 0) {
        printf("Erreur : Le nombre de sommets doit etre positif.\n");
        fclose(f); return 0;
    }

    int n_arcs;
    if (fscanf(f, "%d", &n_arcs) != 1) {
        printf("Erreur : Format de fichier invalide (nombre d'arcs manquant).\n");
        fclose(f); return 0;
    }

    // Allocation
    g->L = allouer_matrice(g->n_sommets);
    g->P = allouer_matrice(g->n_sommets);
    g->est_charge = 1;

    // Initialisation par défaut (Diagonale à 0, reste à INF)
    for (int i = 0; i < g->n_sommets; i++) {
        for (int j = 0; j < g->n_sommets; j++) {
            if (i == j) {
                g->L[i][j] = 0;
                g->P[i][j] = -1; // -1 = NIL
            } else {
                g->L[i][j] = INF;
                g->P[i][j] = -1;
            }
        }
    }

    // Lecture des arcs
    int u, v, w;
    for (int k = 0; k < n_arcs; k++) {
        int lectures = fscanf(f, "%d %d %d", &u, &v, &w);
        if (lectures != 3) {
            printf("Avertissement : Fin de fichier inattendue ou format d'arc incorrect (arc %d).\n", k+1);
            break;
        }

        // Validation des indices des sommets
        if (u < 0 || u >= g->n_sommets || v < 0 || v >= g->n_sommets) {
            printf("Avertissement : Arc %d->%d ignore (sommets hors limites 0-%d).\n", u, v, g->n_sommets-1);
            continue;
        }

        g->L[u][v] = w;
        g->P[u][v] = u;
    }

    fclose(f);
    printf("Succes : Graphe charge (%d sommets, %d arcs theoriques).\n", g->n_sommets, n_arcs);
    return 1; // Succès
}

// --- AFFICHAGE ---

void afficher_matrices(Graphe* g, int k) {
    printf("\n========================================\n");
    if (k == -1) printf("MATRICES INITIALES (D0, P0)");
    else printf("ETAPE k = %d (Passage par sommet %d)", k, k);
    printf("\n========================================\n");

    // Affichage côte à côte pour lisibilité si la taille le permet, sinon l'un sous l'autre
    // Ici, on fait l'un sous l'autre pour éviter les lignes brisées sur petit écran

    printf("MATRICE L (Poids des chemins) :\n");
    printf("      ");
    for(int i=0; i<g->n_sommets; i++) printf("%5d ", i);
    printf("\n");

    for (int i = 0; i < g->n_sommets; i++) {
        printf("%4d |", i);
        for (int j = 0; j < g->n_sommets; j++) {
            if (g->L[i][j] == INF) printf("  INF ");
            else printf("%5d ", g->L[i][j]);
        }
        printf("\n");
    }

    printf("\nMATRICE P (Predecesseurs) :\n");
    printf("      ");
    for(int i=0; i<g->n_sommets; i++) printf("%5d ", i);
    printf("\n");

    for (int i = 0; i < g->n_sommets; i++) {
        printf("%4d |", i);
        for (int j = 0; j < g->n_sommets; j++) {
            if (g->P[i][j] == -1) printf("  NIL ");
            else printf("%5d ", g->P[i][j]);
        }
        printf("\n");
    }
}

// --- ALGORITHME PRINCIPAL ---

void floyd_warshall(Graphe* g) {
    if (!g->est_charge) return;

    // Affichage initial
    afficher_matrices(g, -1);

    // Boucle principale k, i, j
    for (int k = 0; k < g->n_sommets; k++) {
        for (int i = 0; i < g->n_sommets; i++) {
            for (int j = 0; j < g->n_sommets; j++) {

                // Vérification stricte pour éviter l'overflow d'entier
                // Si L[i][k] est INF ou L[k][j] est INF, la somme est INF
                if (g->L[i][k] != INF && g->L[k][j] != INF) {

                    int nouveau_poids = g->L[i][k] + g->L[k][j];

                    if (g->L[i][j] > nouveau_poids) {
                        g->L[i][j] = nouveau_poids;
                        g->P[i][j] = g->P[k][j]; // Mise à jour via k
                    }
                }
            }
        }
        // Affichage intermédiaire demandé par le sujet
        afficher_matrices(g, k);
    }
}

// --- ANALYSE ET RESULTATS ---

int detecter_circuit_absorbant(Graphe* g) {
    // Un circuit absorbant existe si la distance d'un sommet à lui-même devient négative
    for (int i = 0; i < g->n_sommets; i++) {
        if (g->L[i][i] < 0) return 1;
    }
    return 0;
}

// Fonction récursive
void afficher_chemin_recursif(Graphe* g, int depart, int arrivee) {
    if (depart == arrivee) {
        printf("%d", depart);
        return;
    }

    int pred = g->P[depart][arrivee];

    if (pred == -1) {
        // Cas de sécurité, ne devrait pas arriver si appelé correctement
        printf("(Chemin rompu)");
        return;
    }

    afficher_chemin_recursif(g, depart, pred);
    printf(" -> %d", arrivee);
}

// --- MAIN ---

int main() {
    Graphe g;
    initialiser_graphe(&g);

    int continuer_programme = 1;
    char nom_fichier[MAX_FILENAME];

    printf("--- PROJET GRAPHES : FLOYD-WARSHALL ---\n");

    while (continuer_programme) {
        printf("\nEntrez le nom du fichier contenant le graphe (ex: graphe.txt) : ");
        scanf("%255s", nom_fichier); // Limite la lecture à 255 chars pour éviter buffer overflow

        if (charger_graphe_fichier(nom_fichier, &g)) {

            // Exécution
            floyd_warshall(&g);

            // Vérification Circuit Absorbant
            if (detecter_circuit_absorbant(&g)) {
                printf("\n/!\\ ALERTE : Circuit absorbant detecte (cycle de poids negatif).\n");
                printf("Les plus courts chemins ne sont pas definis correctement.\n");
            } else {
                printf("\n--- RECHERCHE DE CHEMINS ---\n");
                int continuer_chemin = 1;
                while (continuer_chemin) {
                    printf("\nVoulez-vous afficher un chemin ? (1: Oui, 0: Non) : ");
                    int choix = lire_entier_securise();

                    if (choix == 0) {
                        continuer_chemin = 0;
                    } else {
                        int depart, arrivee;
                        printf("Sommet de depart (0 a %d) : ", g.n_sommets - 1);
                        depart = lire_entier_securise();

                        printf("Sommet d'arrivee (0 a %d) : ", g.n_sommets - 1);
                        arrivee = lire_entier_securise();

                        // Vérification validité sommets
                        if (depart < 0 || depart >= g.n_sommets || arrivee < 0 || arrivee >= g.n_sommets) {
                            printf("Erreur : Indices de sommets invalides.\n");
                        } else if (g.L[depart][arrivee] == INF) {
                            printf("Resultat : Pas de chemin existant entre %d et %d.\n", depart, arrivee);
                        } else {
                            printf("Chemin minimal (Cout = %d) : ", g.L[depart][arrivee]);
                            afficher_chemin_recursif(&g, depart, arrivee);
                            printf("\n");
                        }
                    }
                }
            }
        }

        // Nettoyage mémoire avant de boucler ou quitter
        detruire_graphe(&g);

        printf("\n--------------------------------------------\n");
        printf("Voulez-vous traiter un autre graphe ? (1: Oui, 0: Non) : ");
        int choix_fin = lire_entier_securise();
        if (choix_fin == 0) continuer_programme = 0;
    }

    printf("\nFin du programme.\n");
    return 0;
}
